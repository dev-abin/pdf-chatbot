Goal

Provide a compact, machine-friendly fingerprint specification you can generate with a GenAI extractor for a PassengerList (or similar) XML node. The fingerprint captures structural, semantic, and provenance cues so you can later compare a new XML node to the fingerprint and decide whether it matches the same pattern (inline identity vs. referenced, attribute vs. element IDs, multiplicity, namespace style, etc.).


---

Fingerprint schema (recommended)

Use a JSON object with these fields. Keep entries deterministic and normalized (lowercase keys, canonical namespace URIs, cardinality as one|zero-or-one|many).

{
  "node_path": "/Root/Booking/Passengers",        // canonical absolute XPath
  "node_name": "Passengers",
  "namespace": {"prefix": "ns", "uri": "urn:example:pnr"},

  "structural_summary": {
    "child_elements": {
      "Passenger": {"count": "many", "order_significant": false},
      "Group": {"count": "zero-or-one"}
    },
    "attributes": {
      "class": {"present": true, "type": "string"}
    },
    "mixed_content": false
  },

  "identity_model": {
    "identity_present_in_node": true,
    "identity_location": "inline",               // "inline" | "external_reference" | "both" | "none"
    "identity_fields": [
      {"name": "PassengerID", "kind": "attribute", "cardinality": "one"},
      {"name": "Name/Given", "kind": "element", "cardinality": "one"}
    ],
    "identity_alternative_keys": [
      {"fields": ["Passport/Number", "Name/Family"], "preferred": false}
    ],
    "identity_references": {
      "ref_attribute": null,
      "ref_element_path": null,
      "external_id_type": null
    }
  },

  "document_references": {                       // presence of IDREFs / hrefs that point outside
    "has_idrefs": false,
    "has_href_refs": true,
    "href_pattern": "urn:internal:passenger:#<id>"
  },

  "value_patterns": {
    "Passport/Number": {"pattern": "^[A-Z0-9]{6,9}$", "example": "A1234567"},
    "BirthDate": {"pattern": "^\\d{4}-\\d{2}-\\d{2}$", "example": "1986-07-05"}
  },

  "semantics": {
    "role_concepts": ["traveler", "infant", "lead-passenger"],
    "sensitive_fields": ["Passport/Number", "NationalID", "BirthDate"]
  },

  "constraints": {
    "required_fields": ["Passenger/Name", "Passenger/PassengerID"],
    "mutually_exclusive": [["Infant/WithSeat","Infant/OnLap"]]
  },

  "formatting": {
    "date_formats": ["YYYY-MM-DD"],
    "currency": null,
    "encoding": "utf-8"
  },

  "namespace_usage": {
    "uses_multiple_ns": false,
    "qualified_names": true
  },

  "metadata": {
    "example_fragment": "<Passenger PassengerID=\"PAX001\">...</Passenger>",
    "source_sample_count": 12,
    "confidence": 0.92
  }
}


---

What to extract (feature list)

1. Canonical path & node name — absolute XPath and normalized local-name.


2. Child element set & multiplicity — element names with cardinality (one/zero-or-one/many).


3. Attributes vs elements — which identity fields are attributes, which are elements.


4. Identity model — whether a unique ID exists inline, as an external reference, or via composite keys.


5. Reference patterns — ID/IDREF, hrefs, URIs and their canonical regex.


6. Value patterns — regexes for common fields (passport, dates, emails, phone).


7. Semantics & sensitive flags — map field names to roles and sensitivity.


8. Namespaces — whether names are namespace-qualified and canonical URIs.


9. Constraints — required fields, cardinality rules, exclusive groups.


10. Examples & provenance — snippet(s) and sample counts to compute confidence.


11. Fingerprint signature — hash of normalized structure (e.g., SHA256 over sorted feature list) for fast equality checks.




---

How a GenAI extractor prompt should look (concise)

Use a deterministic instruction-following prompt that asks the model to parse a provided XML fragment and return only JSON (the fingerprint schema). Example prompt (for your pipeline, parametrize the fragment):

"Given this XML fragment, produce a fingerprint JSON with fields: node_path, node_name, namespace, structural_summary, identity_model, document_references, value_patterns, semantics, constraints, formatting, namespace_usage, metadata. Use canonical XPath for node_path and regex patterns for value_patterns. Output only JSON."


Include a few-shot example mapping a known passenger fragment → matching fingerprint to reduce hallucination.


---

Comparison algorithm (baseline + options)

Start with a hybrid approach:

1. Feature vector + weight

Map fingerprint fields to a vector: e.g., identity_location (one-hot), number of child elements, count of sensitive fields, namespace mismatch flag, etc.

Weighted cosine similarity between vectors.



2. Structural comparison

Compute tree-edit distance (TED) between canonicalized node subtrees (ignore text value differences when needed). Normalize TED by tree size.



3. Schema/key matching

Compare required fields, identity fields, and reference types (inline vs external). Treat mismatch of identity_model as high penalty.



4. Value-pattern check

For fields with regex patterns, compute fraction matching in sample values.




Final score = weighted sum: 0.4 * feature_sim + 0.35 * (1 - normalized_TED) + 0.15 * key_match_score + 0.10 * value_pattern_score.

Threshold guidance (baseline):

≥ 0.85 — same pattern confidently.

0.65–0.85 — likely variant (e.g., versioning, added optional fields).

< 0.65 — different pattern.


Adjust weights per use-case.


---

Pipeline overview (baseline)

1. Sample extraction: pick N representative passenger nodes (N≥5).


2. Normalization: remove non-deterministic values (timestamps, GUIDs), sort child elements if order not significant, canonicalize namespaces.


3. Fingerprinter (GenAI or deterministic parser): generate the JSON fingerprint for the sample set. Use majority voting across samples to fill cardinalities and identity_model.


4. Signature hashing: compute normalized signature (hash) for quick comparisons.


5. Comparator: given new node, canonicalize & generate its fingerprint; compute similarity score vs stored fingerprint using the comparison algorithm.


6. Result: return match score, contributing differences, and field-level diff.




---

Practical tips

Use deterministic parsing (XPath + DOM) for structural facts; reserve GenAI for semantic label inference (e.g., map DocID→passport or infer role_concepts). This avoids hallucinations.

Store multiple fingerprints per pattern (versions) with provenance timestamps and sample counts.

Flag identity-model mismatch as highest-risk difference (inline vs external reference changes processing logic).

For scale, index fingerprints by signature hash and by a compact vector for nearest-neighbor lookup.



---

Example concrete fingerprint (compact)

{
  "node_path": "/Booking/Passengers",
  "node_name": "Passengers",
  "structural_summary": {"child_elements": {"Passenger": "many"}, "attributes": {"count": 1}},
  "identity_model": {"identity_present_in_node": true, "identity_location": "inline", "identity_fields": ["@PassengerID"]},
  "document_references": {"has_href_refs": false},
  "value_patterns": {"Passport/Number": "^[A-Z0-9]{6,9}$", "BirthDate": "^\\d{4}-\\d{2}-\\d{2}$"},
  "semantics": {"role_concepts": ["traveler"], "sensitive_fields": ["Passport/Number","BirthDate"]},
  "metadata": {"example_fragment": "<Passenger PassengerID=\"P001\">...</Passenger>", "source_sample_count": 8}
}


---
